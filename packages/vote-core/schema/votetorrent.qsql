create view ElectionType as select * from (values ('o', 'Official'), ('a', 'Adhoc')) as ElectionType(Code, Name);

-- insert into Signing (Nonce, AuthoritySid, AdminEffectiveAt, Scope, Digest, UserSid, SignerKey, Signature) values ('blah', 'blah', 'blah', 'blah', 'blah', 'blah', 'blah', 'blah');
-- insert into Singature (Nonce, AuthoritySid, AdminEffectiveAt, Scope, Digest, UserSid, SignerKey, Signature) values ('blah', 'blah', 'blah', 'blah', 'blah', 'blah', 'blah', 'blah');
-- given SigningNonce = 'blah'
-- 	insert into AdminSigning (Nonce, AuthoritySid, AdminEffectiveAt, Scope, Digest, UserSid, SignerKey, Signature) values ('blah', 'blah', 'blah', 'blah', 'blah', 'blah', 'blah', 'blah');

create table Network (
	Sid text, -- H(PrimaryAuthoritySid, Name, ImageRef, Relays, TimestampAuthorities, NumberRequiredTSAs, ElectionType) at creation
	Hash text, -- H16(Sid)
	PrimaryAuthoritySid text,
	Name text,
	ImageRef text, -- json object { url?: string, cid?: string }
	Relays text, -- json array of strings - TODO: constraint
	TimestampAuthorities text, -- json array of { url: string } - TODO: constraint
	NumberRequiredTSAs integer default 0,
	ElectionType text, -- references ElectionType(Code)
	primary key (),
	constraint CantDelete check on delete (false),
	constraint SidValid check on insert (Sid = Digest(PrimaryAuthoritySid, Name, ImageRef, Relays, TimestampAuthorities, NumberRequiredTSAs, ElectionType)),
	constraint SidImmutable check on update (new.Sid = old.Sid),
	-- TODO: constraint HashValid check on insert (Hash = H16(Sid)),
	constraint HashImmutable check on update (new.Hash = old.Hash),
	constraint PrimaryAuthoritySidImmutable check on update (new.PrimaryAuthoritySid = old.PrimaryAuthoritySid),
	constraint PrimaryAuthoritySidValid check on insert deferred (exists (select 1 from Authority A where A.Sid = new.PrimaryAuthoritySid)),
	-- TODO: constraint ImageRefValid check (ImageRef is a valid image reference JSON)
	-- TODO: constraint RelaysValid check (Relays is a valid array of strings)
	-- TODO: constraint TimestampAuthoritiesValid check (TimestampAuthorities is a valid array of { url: string })
	constraint NumberRequiredTSAsValid check (NumberRequiredTSAs >= 0 and typeof(new.NumberRequiredTSAs) = 'integer'),
	constraint ElectionTypeValid check (ElectionType in (select Code from ElectionType)),
	constraint NoSigningNonceOnInsert check on insert (SigningNonce is null),
	constraint UpdateNetworkValid check on update (
		-- Only the primary authority can update the network
		exists (select 1 from AdminSignature ADS
			join AdminSigning A on A.Nonce = ADS.Nonce and A.AuthoritySid = new.PrimaryAuthoritySid
			where ADS.Nonce = new.SigningNonce
				and A.Scope = 'rn'
		)
	)
)
	with context on update, delete ( SigningNonce text );

create view Scope as select * from (values
	('rn', 'Revise Network'),
	('rad', 'Revise or replace the Admin'),
	('vrg', 'Validate registrations'),
	('iad', 'Invite other Authorities'),
	('uai', 'Update Authority Information'),
	('ceb', 'Create/Edit ballot templates'),
	('mel', 'Manage Elections'),
	('cap', 'Configure Authority Peers')
) as Scope(Code, Name);

create table Authority (
	Sid text, -- H(Name, DomainName, ImageRef, InviteSlotCid, InviteSignature) at creation
	Name text,
	DomainName text null,
	ImageRef text null, -- json object { url?: string, cid?: string }
	primary key (Sid),
	constraint CantDelete check on delete (false),
	constraint AdminRequired check on insert deferred (exists (select 1 from Admin A where A.AuthoritySid = new.Sid)),
	constraint NewSidValid check on insert (Sid = Digest(Name, DomainName, ImageRef, InviteSlotCid, InviteSignature)),
	constraint SidImmutable check on update (new.Sid = old.Sid),
	-- TODO: constraint ImageRefValid check (ImageRef is a valid image reference JSON)
	constraint AuthorityValid check on insert (
		-- Very first authority in the network - shoe-in, no Invite, no signing
		(SigningNonce is null and InvitateSignature is null and not exists (select 1 from Authority))
			-- or Valid Invite for this authority
			or (SigningNonce is not null xor InviteSignature is not null)
	),
)
	with context ( SigningNonce text null, InviteSlotCid text null, InviteSignature text null );

-- Administration
create table Admin (
	AuthoritySid text,
	EffectiveAt datetime,
	ThresholdPolicies text default '[]', -- json array of { scope: string, threshold: integer } - if not set for a scope, 1 is assumed
	primary key (AuthoritySid, EffectiveAt),
	constraint OfficerRequired check on insert deferred (
		exists (select 1 from Officer O where O.AuthoritySid = new.AuthoritySid and O.AdminEffectiveAt = new.EffectiveAt
			and exists (select scope from json_array_elements_text(O.Scopes) S(s) where s = 'rad')
		)
	),
	constraint AuthoritySidValid check deferred (exists (select 1 from Authority A where A.Sid = new.AuthoritySid)),
	constraint EffectiveAtValid check (isISODatetime(EffectiveAt) and endswith(EffectiveAt, 'Z')),
	-- TODO: constraint ThresholdPoliciesValid check (valid json array of { scope: string, threshold: integer }),
	constraint AdminValid check deferred (
		-- Initial admin for the first authority - no invite, no signing
		(
			SigningNonce is null and InviteSlotCid is null and InviteSignature is null
				and not exists (select 1 from Authority where Sid <> new.AuthoritySid)
		)
			-- or, if an invite is present this is a new authority - invite is valid
			or (
				SigningNonce is null and InviteSlotCid is not null and InviteSignature is not null
					and exists (
						select 1 from InviteResult I where I.SlotCid = InviteSlotCid and I.IsAccepted
							and I.Digest = Digest(
								AuthoritySid, -- This is already a hash of the authority
								(select DigestAll(Digest(EffectiveAt, ThresholdPolicies)) over (order by EffectiveAt)
									from Admin A where A.AuthoritySid = new.AuthoritySid),
								(select DigestAll(Digest(AdminEffectiveAt, UserSid, Title, Scopes)) over (order by AdminEffectiveAt, UserSid)
									from Officer O where O.AuthoritySid = new.AuthoritySid)
							)
					)
			)
			-- or, if a signing nonce is present this is a new or updated administration for existing authority - signing nonce is valid
			or (
				SigningNonce is not null and InviteSlotCid is null and InviteSignature is null
					and exists (select 1 from AdminSigning A where A.Nonce = new.SigningNonce and A.IsAccepted)
			)

	constraint SigningInviteMutex check (context.SigningNonce is null xor context.InviteSignature is null),
	-- Case 1a: First Authority - first authority inserted - admin, officers, and authority are all inserted together
	-- TODO
)
	with context ( SigningNonce text null, InviteSlotCid text null, InviteSignature text null );

create view CurrentAdmin as
	select AuthoritySid, max(EffectiveAt) as EffectiveAt
		from Admin
		where EffectiveAt <= datetime('now')
		group by AuthoritySid;

create table Officer (
	AuthoritySid text,
	AdminEffectiveAt datetime,
	UserSid text,
	Title text,
	Scopes text default '[]', -- json array of strings
	primary key (AuthoritySid, AdminEffectiveAt, UserSid),
	-- NOT NEEDED - AuthoritySid is validated through Admin
	-- constraint AuthoritySidValid check (exists (select 1 from Authority A where A.Sid = new.AuthoritySid)),
	constraint AdminValid check deferred (exists (select 1 from Admin A where A.AuthoritySid = new.AuthoritySid and A.EffectiveAt = new.AdminEffectiveAt)),
	constraint UserSidValid check (exists (select 1 from User U where U.Sid = new.UserSid)),
	constraint ScopesValid check (not exists (select 1 from json_array_elements_text(Scopes) S(s) where s not in (select Code from Scope))),
)
	with context ( SigningNonce text null, InviteSignature text null );

create assertion AuthorityAndAdminValid check (

	-- Case 1b: New Authority - invitation valid - admin, officers, and authority are all inserted together
	-- Case 2: Update existing authority - signing nonce from currently effective admin is valid - only authority can change
	-- Case 3: Insert/update/delete of existing Admin - signing nonce from currently effective admin is valid - admin and officers can change together

	not exists (
	-- Threshold policies are valid - the number of Officers for each scope is at least the threshold
	select 1 from Admin A
		where exists (select 1 from json_array_elements_text(A.ThresholdPolicies) TP(tp)
			where tp.threshold > (select count(*) from Officer AD
				where A.AuthoritySid = AD.AuthoritySid and A.AdminEffectiveAt = AD.AdminEffectiveAt
					and tp.scope in (select policy from json_array_elements_text(AD.Scopes) S(s) where s = tp.scope)
			)
		)
));

create index OfficerUser on Officer (UserSid); -- include (Scopes)

-- Note: proposed aren''t dependencies, just a workflow for constructing a fully signed admin

-- A signing "session" for an Admin
create table AdminSigning (
	Nonce text, -- Random ID
	AuthoritySid text,
	AdminEffectiveAt datetime,
	Scope text, -- references Scope(Code)
	Digest text, -- Content hash to be signed - Base64url encoded sha256
	UserSid text, -- Officer who is instigator the signing session
	SignerKey text, -- Instigator's signing key
	Signature text, -- Instigator's signature of this row
	primary key (Nonce),
	constraint InsertOnly check on update, delete (false),
	constraint ScopeValid check (exists (select 1 from Scope S where S.Code = new.Scope)),
	constraint UserSidValid check (exists (
		select 1 from Officer O
			where O.UserSid = new.UserSid
				and O.AdminEffectiveAt = new.AdminEffectiveAt
				and O.AuthoritySid = new.AuthoritySid
	)),
	constraint SignerKeyValid check (exists (select 1 from UserKey K where K.UserSid = new.UserSid and K.Key = new.SignerKey and K.Expiration > datetime('now'))),
	constraint SignatureValid check (SignatureValid(Digest(Nonce, AuthoritySid, AdminEffectiveAt, Scope, Digest, UserSid), Signature, SignerKey))
);

-- Officer''s signature on the signing session
create table OfficerSignature (
	SigningNonce text,
	UserSid text,	-- Particular Officer
	SignerKey text,	-- User's particular signing key
	Signature text,	-- User's signature of the digest
	primary key (SigningNonce, UserSid),
	constraint InsertOnly check on update, delete (false),
	-- Key is valid for the user and the UserSid is valid
	constraint SignerKeyValid check (
		exists (select 1 from UserKey K where K.UserSid = new.UserSid and K.Key = new.SignerKey and K.Expiration > datetime('now'))
	),
	-- User is an Officer with the required scope
	constraint OfficerValid check (
		exists (select 1 from AdminSigning ADS
			join Officer O on O.AuthoritySid = ADS.AuthoritySid and O.AdminEffectiveAt = ADS.AdminEffectiveAt
			where ADS.Nonce = new.SigningNonce
				 and O.UserSid = new.UserSid
				 and ADS.Scope in (select policy from json_array_elements_text(O.Scopes) S(s) where s = new.Scope)
		)
	),
	constraint SignatureValid check (exists (
		select 1 from AdminSigning ADS
			where ADS.Nonce = new.SigningNonce
				and SignatureValid(ADS.Digest, Signature, SignerKey)
	))
);

-- The final Admin signature output - only exists if required threshold of signatures are met - exists to avoid long validation
create table AdminSignature (
	SigningNonce text,
	primary key (SigningNonce),
	constraint InsertOnly check on update, delete (false),
	-- Satisfies the threshold policies of the Admin for the given scope
	constraint SignatureValid check (
		(select count(*) from OfficerSignature ADS where ADS.SigningNonce = new.SigningNonce)
			>= (
				select threshold from Admin A
					join AuthoritySignature ATS on ATS.AuthoritySid = A.AuthoritySid and ATS.AdminEffectiveAt = A.EffectiveAt
					cross join lateral json_array_elements_text(A.ThresholdPolicies) TP(tp) on tp.scope = ATS.Scope
					where ATS.Nonce = new.SigningNonce
			)
	)
);

-- The ProposedAdmin [Nonce] is recorded as having existed, enabling deletion without risk of unauthorized re-insertion
create table ExistedProposedAdmin (
	Nonce text,
	primary key (Nonce),
);

create table ProposedAdmin (
	Nonce text,
	AuthoritySid text,
	EffectiveAt datetime,
	ThresholdPolicies text default '[]', -- json array of { policy: string (Scope), threshold: integer }
	primary key (AuthoritySid, EffectiveAt),
	constraint InsertValid check on insert (not exists (select 1 from ExistedProposedAdmin E where E.Nonce = new.Nonce)),
	constraint DeleteValid check on delete (exists (select 1 from ExistedProposedAdmin E where E.Nonce = new.Nonce)),
	constraint AuthoritySidValid check (exists (select 1 from Authority A where A.Sid = new.AuthoritySid)),
	constraint EffectiveAtValid check on insert, update (isISODatetime(EffectiveAt) and endswith(EffectiveAt, 'Z')),
	--constraint ThresholdPoliciesValid check (...), -- TODO: constraint
	constraint UserValid check (exists (
		select 1 from Officer O
			join CurrentAdmin CA on CA.AuthoritySid = O.AuthoritySid and CA.EffectiveAt = O.AdminEffectiveAt
			join UserKey K on K.UserSid = O.UserSid and K.Key = context.UserKey and K.Expiration > datetime('now')
			where O.UserSid = context.UserSid and O.AuthoritySid = new.AuthoritySid
				and exists(select 1 from json_array_elements_text(O.Scopes) S(s) where s = 'rad')
				and SignatureValid(
					Digest(Nonce, Coalesce(new.AuthoritySid, old.AuthoritySid),
						Coalesce(new.EffectiveAt, old.EffectiveAt), ThresholdPolicies),
					context.Signature,
					context.UserKey
				)
	)),
)
	with context ( UserSid text, UserKey text, Signature text );

alter table ExistedProposedAdmin
	add constraint NonceValid check (exists (select 1 from ProposedAdmin P where P.Nonce = new.Nonce));

create table ProposedOfficer (
	AuthoritySid text,
	AdminEffectiveAt datetime,
	AdminNonce text,
	ProposedName text,
	Title text,
	Scopes text default '[]', -- json array of strings
	OfficerKey text,	-- Key of some current Officer
	OfficerSignature text,
	primary key (AuthoritySid, AdminEffectiveAt, ProposedName),
	constraint AuthoritySidValid check (exists (select 1 from Authority A where A.Sid = new.AuthoritySid)),
	constraint AdminValid check (exists (select 1 from Admin A where A.AuthoritySid = new.AuthoritySid and A.Revision = new.AdminRevision)),
	constraint CantDelete check on delete (false),
	constraint ScopesValid check (not exists (select 1 from json_array_elements_text(Scopes) S(s) where s not in (select Code from Scope))),
	constraint OfficerKeyValid check (exists (select 1 from UserKey K
		-- Most recent effective Admin
		join Officer A on A.UserSid = K.UserSid and A.AdminEffectiveAt <= datetime('now')
		join Admin AD on AD.AuthoritySid = A.AuthoritySid and AD.E
		where K.UserSid = new.OfficerKey and K.Expiration > datetime('now')))
);

-- Extension of ProposedOfficer to associate a specific UserSid and include the user''s signature
create table ProposedOfficerUser (
	AuthoritySid text,
	AdminEffectiveAt datetime,
	ProposedName text,
	UserSid text,
	UserKey text,
	UserSignature text,
	primary key (AuthoritySid, AdminEffectiveAt, ProposedName),
	constraint ProposedOfficerValid check (exists (select 1 from ProposedOfficer PA where PA.AuthoritySid = new.AuthoritySid and PA.AdminEffectiveAt = new.AdminEffectiveAt and PA.ProposedName = new.ProposedName)),
	constraint UserSidValid check (exists (select 1 from User U where U.Sid = new.UserSid)),
	constraint UserKeyValid check (exists (select 1 from UserKey K where K.UserSid = new.UserSid and K.Key = new.UserKey and K.Expiration > datetime('now'))),
	constraint CantDelete check on delete (false),
	constraint SignatureValid check (exists (
		select 1 from ProposedOfficer PA
			where PA.AuthoritySid = new.AuthoritySid and PA.AdminRevision = new.AdminRevision and PA.ProposedName = new.ProposedName and PA.UserSid = new.UserSid and PA.SignerKey = new.SignerKey and PA.Signature = new.Signature
			-- and SignatureValid(
			-- 	Digest(new.AuthoritySid, new.AdminRevision, new.UserSid, PA.Title, PA.Scopes),
			-- 	Signature,
			-- 	SignerKey
			-- )
	))
);

create table InviteSlot (
	Cid text,
	-- Name of person or authority for informational purpose and/or manually catch abuse
	Name text,
	Expiration text,
	InviteKey text, -- public key of temporary Invite key pair
	InviteSignature text,
	SigningNonce text, -- Admin approval, including scope (implies the type of invite, e.g. authority, officer, keyholder, registrant)
	primary key (Cid),
	constraint CidValid check (Cid = Digest(Name, Expiration, InviteKey, InviteSignature, SigningNonce)),
	constraint ExpirationValid check (Expiration > datetime('now')),
	-- Prooves that the inviter has a valid private key corresponding to the public key in the Invite slot
	constraint InviteSignatureValid check (SignatureValid(Digest(Cid, Type, Name, Expiration), InviteSignature, InviteKey)),
	constraint InsertOnly check on update, delete (false)
)

create index InviteSlotSigningNonce on InviteSlot (SigningNonce, Cid);

-- A single signing can encompass a batch of Invite slots, so validate the whole batch at once
create assertion InviteSlotSigningValid check (not exists (
	select 1 from (
		select SigningNonce, DigestAll(Cid) over (order by Cid) as Digest from InviteSlot I
	) SND
		where not exists (
			select 1 from AdminSigning SIG
				where SIG.SigningNonce = SND.SigningNonce and SIG.Digest = SND.Digest
		)
));

-- Acceptance or rejection of Invite, created before resulting object
create table InviteResult (
	SlotCid text primary key,
	IsAccepted boolean,	-- If Not accepted, Digest must be null
	Digest text null,	-- On whatever the invited party is intending to create - not validated here besides not null if IsAccepted
	InviteSignature text,	-- Signs H(SlotCid, Digest, IsAccepted)
	constraint InsertOnly check on update, delete (false),
	constraint SigningValid check (exists (
		select 1 from InviteSlot I
			join AdminSignature SIG on SIG.Nonce = I.SigningNonce
			where I.Cid = new.SlotCid)
	),
	constraint SignatureValid check (exists (
		select 1 from InviteSlot S
			where S.Cid = new.SlotCid and SignatureValid(Digest(SlotCid, Digest, IsAccepted), new.InviteSignature, S.InviteKey)
	)),
	constraint DigestValid check (
		(not IsAccepted and new.Digest is null)
			or (IsAccepted and new.Digest is not null)
	),
);

create view AcceptedInvite as
	select IR.SlotCid, IR.IsAccepted, IR.Digest, IR.InviteSignature, SIG.Scope
		from InviteResult IR
		join InviteSlot S on S.Cid = IR.SlotCid
		join AdminSigning SIG on SIG.SigningNonce = S.SigningNonce
		where IR.IsAccepted;

create view UserKeyType as
	select Code, Name from (values ('M', 'Mobile'), ('Y', 'Yubico')) as UserKeyType(Code, Name);

create table User (
	Id text, -- Random ID
	Name text,
	ImageRef text null, -- json object { url?: string, cid?: string }
	primary key (Id),
	constraint UserValid check deferred (
		-- Must be associated with a keyholder
		exists (select 1 from Keyholder K where K.UserId = new.UserId)
			-- or must be associated with an officer
			or exists (select 1 from Officer O where O.UserId = new.UserId)
	),
	constraint UserKeyValid check deferred (
		-- Must be a non-expired key for the user
		exists (select 1 from UserKey K where K.UserId = new.UserId)
	),
	constraint CantDelete check on delete (false),
	constraint ValidModification check (new.Id = old.Id)
);
-- Note: we don''t need to verify an invitation slot or anything - users are validated as part of whatever they are referenced by

create table UserKey (
	UserId text, -- references future User.Id
	Type text, -- references UserKeyType(Code)
	Key text,
	Expiration text,
	primary key (UserSid, Key),
	constraint UserIdValid check deferred (
		exists (select 1 from User U where U.Id = new.UserId)
	),
	constraint InsertValid check on insert deferred (
		-- First key for the user - just accept it
		(
			not exists (select 1 from UserKey K where K.UserId = new.UserId and K.Key <> new.Key)
				and UserKey is null
		)
			-- or must be a non-expired key for the user
			or exists (select 1 from UserKey K where K.UserId = new.UserId and K.Key = new.UserKey and K.Expiration > datetime('now'))
	),
	constraint DeleteValid check on delete (
			-- must be a non-expired key for the user
			exists (select 1 from UserKey K where K.UserId = old.UserId and K.Key = old.UserKey and K.Expiration > datetime('now'))
				-- and not the last key for the user
				and exists (select 1 from UserKey K where K.UserId = old.UserId and K.Key <> old.Key)
	),
	constraint SignatureValid check (UserKey is null or SignatureValid(Digest(UserId, Type, Key, Expiration), Signature, UserKey)),
	constraint NoUpdate check on update (false),
	constraint ExpirationFuture check (Expiration > datetime('now'))
)
	with context ( UserKey text null, Signature text null );

